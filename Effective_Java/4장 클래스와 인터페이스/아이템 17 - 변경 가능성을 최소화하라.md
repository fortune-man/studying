	

- 클래스는 변경할 수 있는 부분을 최소한으로 줄이는 것이 좋습니다.
- 불변 클래스와 그 사용법에 대해 배워보겠습니다.

## 불변 클래스

- 인스턴스의 내부 값을 수정할 수 없는 클래스입니다.
- 가변 클래스보다 설계하고 구현하고 사용하기 쉽습니다.
- 오류가 생길 가능성이 적습니다.

### 불변 클래스 생성 규칙

1. 객체의 상태를 변경할 수 있는 메서드(변경자)를 제공하지 않습니다.
2. 클래스를 확장할 수 없도록 합니다.
	- 상속을 불가능하게 만듭니다.
3. 모든 필드를 `final`로 선언합니다.
	- 시스템이 강제하는 수단을 이용해 설계자의 의도를 명확히 드러내는 방법입니다.
4. 모든 필드를 `private`으로 선언합니다.
	- 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막아줍니다.
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 합니다.
	- 클라이언트가 객체 참조를 얻게 해서는 안 됩니다.

### 불변 클래스 예시

```java
public final class Complex {

	private final double re;
	private final double im;

	public Complex(double re, double im) {
		this.re = re;
		this.im = im;
	}

	public double realPart() {
		return re;
	}

	public double imaginaryPart() {
		return im;
	}

	public Complex plus(Complex c) {
		return new Complex(re + c.re, im + c.im);
	}
}
```

- 책의 불변 복소수 클래스 예제를 간략화한 코드입니다.
- `plus()` 메서드는 인스턴스를 수정하지 않고 새로운 인스턴스를 생성하여 반환합니다.
	- 피연산자 자체는 그대로인 함수형 프로그래밍의 특징을 띄고 있습니다.

> 함수형 프로그래밍(functional programming)
> - 자로처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임


### 불변 클래스의 특징

- 불변 클래스는 한 번 만든 클래스를 재활용하는 것이 좋습니다.
	- 인스턴스를 상수형태로 제공하는 방법
	- 정적 팩터리 형식으로 제공하여 자주 사용하는 인스턴스를 캐싱하는 방법
- 불변 클래스는 `clone()` 메서드나 복사 생성자를 제공하지 않는 것이 좋습니다.

#### 불변 객체의 특징

- 불변 객체는 스레드 안전하기 때문에 동기화할 필요가 없고, 안심하고 공유할 수 있습니다.
- 불변 객체 끼리는 내부 데이터를 공유할 수 있습니다.
	- `BigInteger`의 경우 int 배열을 이용해서 값을 제공하는데 부호를 바꿔주는 `negate()` 메서드는 실제로 같은 int 배열을 참조하고, 부호만 변경해서 반환합니다.
- 객체를 생성할 때 다른 불변 객체들을 구성요소로 사용하면 좋습니다.
	- 값이 바뀌지 않는 구성요소들로 이뤄진 객체는 불변식을 유지하기 편합니다.
	- 예) 불변 객체를 `Map`의 키로 사용하는 것
- 불변 객체는 실패 원자성을 제공합니다.
	- 이는 메서드에서 예외가 발생한 경우에도 객체의 값은 호출 전과 같은 상태여야 한다는 성질입니다.

#### 불변 클래스의 단점

- 값이 다르면 반드시 독립된 객체를 생성해야 합니다.
	- 값의 가짓수가 많다면 자원의 낭비가 있을 수 있습니다.
- 생성해야 하는 객체를 완성하기 까지의 단계가 많고, 중간 단계에서 생성한 객체들이 버려지는 경우 성능 문제가 심각해집니다.

#### 단점을 극복하는 방법

- 다단계 연산들을 예측하여 기본 기능으로 제공하는 방법
	- 클라이언트가 원하는 복잡한 연산들을 정확히 예측이 가능할 때 기본 기능으로 제공하는 것이 좋습니다.
	- `BigInteger` 클래스로 예를 들자면 내부적으로 다단계 연산 속도를 높혀주는 가변 동반 클래스가 있습니다.
	- 가변 동반 클래스를 직접 사용하는 것은 `BigInteger`를 사용하는 것보다 어렵기 때문에 BigInteger 클래스가 `package-private`으로 두고 복잡한 부분을 대신 처리해줍니다.
- 가변 동반 클래스를 public 으로 제공하는 방법
	- 클라이언트들이 원하는 복잡한 연산들을 예측할 수 없을 때 최선의 방법입니다.
	- 대표적인 예시로 `String` 클래스의 가변 동반 클래스인 `StringBuilder`가 있습니다.

#### 불변 클래스를 유연하게 설계하는 방법

- 상속하지 못하게 하는 방법은 final 클래스로 선언하는 것이지만 더 유연한 방법이 있습니다.
- `private` 생성자를 사용하고, `public` 정적 팩터리 메서드를 제공하는 방법입니다.

```java
public class Complex {

	private final double re;
	private final double im;

	private Complex(double re, double im) {
		this.re = re;
		this.im = im;
	}

	public static Complex valueOf(double re, double im) {
		return new Complex(re, im);
	}
}
```

- 정적 팩터리 메서드로 제공하면 유연하고, 객체 캐싱을 통해 성능을 증가시킬 수도 있습니다.

#### BigInteger 와 BigDecimal

- 두 클래스는 재정의 가능한 상태로 설계되었기 때문에 사용시 주의해야 합니다.
- 신뢰할 수 없는 클라이언트에게 해당 클래스의 인스턴스를 받았을 때 다음과 같이 하위 클래스가 아닌지 검사해야 합니다.

```java
public static BigInteger safeInstance(BigInteger val) {
	return val.getClass() == BigInteger.class ?
			val : new BigInteger(val.toByteArray());
}
```

- 하위 클래스라고 생각된다면, 방어적 복사를 통해 사용해야 합니다.

---

### 정리

- `getter()` 메서드가 있다고 해서 무조건 `setter()` 메서드를 생성하는 건 좋지 않습니다.
- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 합니다.
- 불변으로 만들 수 없는 클래스라면 변경할 수 있는 부분을 최소한으로 줄이는 것이 좋습니다.
- 합당한 이유가 없다면 모든 필드는 `private final` 이어야 합니다.
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 합니다.