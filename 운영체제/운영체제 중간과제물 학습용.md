## 간단 설명

프로세스 
- 실행중인 프로그램
스케줄링 
- 프로세스 처리 순서를 결정하는 과정

대기시간 = cpu사이클 시작하는 시간 - 도착시간
반환시간 = cpu사이클 끝나는 시간 - 도착시간

---

## 1. 다음에 대해 답하시오.

### (1) 선점 스케줄링 정책과 비선점 스케줄링 정책 중 한 가지만 골라 설명하시오.  

### 선점 스케줄링 정책

높은 우선순위의 프로세스를 먼저 처리해야 하는 경우 선택해야 하는 스케줄링 정책이라고 생각합니다.

문맥 교환에 따른 오버헤드 발생을 감수하고 

실행 중인 프로세스에 인터럽트를 걸어 다른 프로세스에 디스패치하는 방법을 사용합니다.

두 스케줄링 정책 중 한 가지를 선택하기 위해서는

문맥 교환을 허용하고 오버헤드 발생을 감수해야 하는 것과

프로세스가 대기상태 혹인 종료상태로 전이될 때까지 계속 실행상태에 있어야 하는 경우를 감수해야하는 것 중

어떤 것을 선택하고 트레이드 오프하는 것이 적절할지,
결정에 대한 근거를 하나씩 확보해나가는 습관이 중요하다고 이해하고 있습니다.

### (2) (1)에서 고른 정책을 사용하는 스케줄링 알고리즘 한 가지
RR (Round Robine) 알고리즘

시간 할당량을 지정하여 정해진 범위 내로 실행을 공평하게 제한하는 아이디어가 멋진 알고리즘입니다.

준비 큐에 도착한 순서대로 디스패치하는 점이 FCFS의 단순함을 가지면서도

시간 할당량을 모두 소비 시, 해당 프로세스를 준비 큐 마지막으로 배치시키는 점을 통해

중요한 프로세스가 나중에 수행될 수도 있다는 단점을 어느정도 보완되어 훌륭합니다.

다만, 시간 할당량을 정말 적절하게 지정해주어야 한다는 점을 주의해야 합니다.

너무 크면 FCFS 스케줄링과 동일하거나 오히려 그것보다 못 한 결과를 가져올 위험도 있고,

시간 할당량이 너무 작으면 문맥 교환이 발생하는 빈도수가 높아지면서

자연스럽게 높은 오버헤드가 따라오게 됩니다.

선점 스케줄링과 비선점 스케줄링 알고리즘 중 어떤게 가장 좋은 선택일지 어떤 상황에서 선택해야 할지 고민하며 강의를 들어보니

제 생각엔 최적의 시간 할당량을 지정할 수만 있다면 일반적으로 '라운드로빈 알고리즘이 일반적으로 가장 좋은 선택 아닐까?' 라고 생각했습니다.

얼마 후 시간 할당량이 적절하지 않더라도 시스템의 부하를 관찰하고 동적으로 조정할 수 있다면 그것이 가장 합리적일거라는 생각도 떠올랐습니다.  

그래서 추가 학습을 해보니 Linux의 CFS(Completely Fair Scheduler)가 프로세스들의 CPU 사용시간을 추적하고 이를 이용하여 각 프로세스에 대한 가중치를 동적으로 조절한다는 사실을 알게 되었습니다.

CPU 시간을 할당을 공정하게 하면서, CPU 사용 시간이 적은 프로세스들에게 우선적으로 CPU 시간을 할당하는 것이 가능해집니다.

만약 단순하면서 공정한 효율의 스케줄링을 지향한다면 FCFS -> RR -> CFS 순서로 접근해보는게 이치에 맞을 것 같다라고 이해하고 있습니다.

## 2. 프로세스별 도착시각과 필요한 CPU 사이클이 표와 같을 때, 다음에 대해 답하시오. (15점)

| 프로세스 |A| B |C |D |E|
| -- | -- | -- | -- | -- | -- | 
|도착시각 |0 |2 |3 |5 |7|
|CPU 사이클| 6 |3| 1 |2 |4|


### (1) 1.(2)에서 고른 스케줄링 알고리즘을 이용하여 프로세스들이 수행되는 순서를 구체적인 시각과 함께 표시하시오. 그렇게 순서가 정해지는 과정에 대해서도 자세히 설명하시오.

시간할당량 = 4

#### 시간할당량을 저렇게 지정한 근거
각 프로세스가 단순하면서 균등하게 스케줄링되는 장점을 살리고 싶었습니다.
오버헤드 발생 빈도가 적절하고 CPU 사용 시간이 공평하게 보유되는 그림을 그리다보니 CPU 사이클의 최대값, 최소값의 평균을 반올림한 값을 사용하게 되었습니다.

시간할당량이 4로 지정된 스케줄링 내에서
1. A가 CPU 사이클 4를 소모한 후, CPU 사이클 2를 남긴 A가 준비 큐에서 대기합니다.
2. 시간할당량 내로 B -> C -> D -> E -> A 순서로 각각 CPU 사이클 3, 1, 2, 4 소모한 후 반환합니다.
3. 준비 큐에 있던 A를 호출하여 남은 CPU 사이클 2를 소모한 후 반환합니다.

위의 설명을 이해하기 쉽도록 표를 작성해봤습니다.

시각             0   2   3    4  5    7   8   10             14        16
도착시각      A    B  C        D    E
CPU 사이클 |     A (6)   |    B   | C | D |        E       |     A    |
준비큐          |     A(2)    |                                   A(2) 호출 |


[![라운드로빈](https://user-images.githubusercontent.com/79819812/231979588-d77af10b-9d6d-41e5-a3c2-dd945db4f78c.jpeg)](https://user-images.githubusercontent.com/79819812/231979588-d77af10b-9d6d-41e5-a3c2-dd945db4f78c.jpeg)

### (2) (1)의 결과에 대해 각 프로세스의 반환시간을 구하고, 평균반환시간을 계산과정과 함께 제시하시오.

반환시간 = CPU 사이클 종료 시각 - 도착 시각

1. 각 프로세스별 반환시간

|프로세스|  A|   B|   C|   D|   E|
|-|-|-|-|-|-|
|반환시간| 16|   5|   8|   5|   7|


2. 평균반환시간 

(반환시간의 합) / (프로세스 개수) 
= 41 / 5 
= 8.2 

(3) 1.(1)에서 고르지 않은 정책을 사용하는 스케줄링 알고리즘 한 가지만 고르고, 고른 알고리즘을 이용하여 각 프로세스의 반환시간과 함께 평균반환시간도 구하시오.

### 비선점 스케줄링 정책

오버헤드가 발생하면 안 되는 경우, 감수할 수 없는 경우에 선택할 수 있는 스케줄링 정책이라고 생각합니다.

강제적인 문맥 교환이 없어서 오베헤드가 발생하지 않는 대신

이미 실행 중인 프로세스의 길이에 따라 더 짧은 프로세스가 오래 기다리게 되는

경우가 발생하여 비효율을 고려한 적절한 선택이 필요하다고 생각합니다.

비선점 스케줄링 정책 중 FCFS 알고리즘을 이용하여 프로세스를 스케줄링한 결과를 표로 표현하면 다음과 같습니다.

>  FCFS
>- First Come First Serve, 오버헤드 발생없이 단순하게 먼저 온 순서대로 실행하는 스케줄링 방법입니다.
>- 짧은 프로세스가 순서 때문에 긴 프로세스를 기다려야 할 수 있다는 점을 고려해야 합니다.

시각             0   2   3    4  5  6  7     9        10         12                    16
도착시각      A    B  C        D      E
CPU 사이클 |         A (6)        |  B(3) |  C(1) |  D(2)  |       E(4)         |

[![fcfs](https://user-images.githubusercontent.com/79819812/231979778-faf1733d-aae0-4179-9c2a-394982a5145c.jpeg)](https://user-images.githubusercontent.com/79819812/231979778-faf1733d-aae0-4179-9c2a-394982a5145c.jpeg)

반환시간과 평균반환시간을 구하는 식은 2.(2)에서 재사용했습니다.

1. 프로세스별 반환시간
|프로세스| A   |B    |C  | D  | E|
|-|-|-|-|-|-|
|반환시간 |6  | 7    |7    |7  |  9|


2. 평균반환시간 
36 / 5
= 7.2

---

P.S
과제를 잘 작성하고 학점을 관리하는 것도 중요하지만 그것으로 충분한지에 대한 확신이 없었습니다.
그래서 스스로 깊게 빠져드는 경험을 지속하고자 노력해봤
결과적으로 운영체제라는 어려워보이는 과목을 내가 끝까지 완주할 수 있을까? 라는 두려움을 극복하는데 큰 도움이 됨과 동시에
순간순간 집중하는 즐거움을 얻어갈 수 있었습니다.
부족한 과제물 읽어주셔서 감사드립니다. 좋은 하루 되십시오! :)
