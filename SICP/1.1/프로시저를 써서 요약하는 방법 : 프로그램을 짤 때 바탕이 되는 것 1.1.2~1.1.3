![컴퓨터 프로그램의 구조와 해석](https://image.aladin.co.kr/product/7512/20/cover500/8966261701_1.jpg)

### 출처 : [컴퓨터 프로그램의 구조와 해석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=75122015)

---
### 1.1.2이름과 환경

프로그래밍 언어에서 아주 중요한 기능!
computational object(계산 물체)에 이름을 붙이는 것이라고 한다.
이 때 이름은 variable(변수), 그 변수의 값은 value(값)가 된다.
> scheme에선 이름을 지을 때 define 사용

#### 변수의 구조
```scheme
;: (define size 2)
;: size
;: (* 5 size)
;;;  10
```
식을 실행기에 건네면,
2라는 값에 size라는 이름을 붙이고
한 번 size라는 이름의 값을 2로 정했으니
그 다음부터는 size라는 이름만으로 2라는 값을 나타낼 수 있다.
나는 이것을
입력 -> 메모리 할당 -> 참조값 출력 원리라고 이해했다.

변수 활용 예시
```scheme
;: (define pi 3.14159)
;: (define radius 10)
;: (* pi (* radius radius))
;;; 314.159
;: (define circumference (* 2 pi radius))
;: circumference
;;; 62.8318
```

circumference처럼 복잡한 식을 계산한 값에 알기 쉬운 이름을 붙여서 쓸 수도 있다.
복잡한 프로그램을 구축할 땐 작고 단순한 구조에서 점점 더 복잡하게 확장되어가는 방식을 따르기 때문에,
필요한 물체에 하나씩 이름을 붙여 쓸 수 있는 실행기를 쓰면 편하다.

어떤 값에 symbol(이름)을 붙여 두었다가 뒤에 그 이름으로 필요한 값을 찾아 쓸 수 있다는 말은,
실행기 속 어딘가에 name-object(이름-물체)의 싸아을 저장해 둔 메모리가 있다는 뜻이다.
이러한 기억 공간을 environment(환경)라고 한다.
>계산 과정에서 쓰는 환경이 하나만 있는게 아님을 알게 되며, 지금 말하는 환경은 맨 바깥쪽에 있는 global environment(바탕 환경)을 말한다고 한다.

### 1.1.3 combination(엮은식)을 계산하는 방법

어떤 일을 제대로 하려면, 큰 일을 작은 일로 알맞게 나눈 다음 작은 일을 어떤 차례로 해나갈지 정해야 한다.

실행기가 combination(엮은 식)의 값을 계산하는 차례가 다음과 같다고 가정한다면,
>
1. 엮은식에서 subexpression(부분 식)의 값을 모두 구한다.
2. 엮은식에서 맨 왼쪽에 있는 식(연산자)의 값은 프로시저,
나머지 식(피연산자)의 값은 인자가 된다.
프로시저를 인자에 적용하여 엮은 식의 값을 도출한다.

#### Recursive
뻔한 규칙 같지만, 프로세스를 다룰 때 중요하게 다루어야 할 것이 드러나있다.
이 계산 규칙은 자연스레 처음으로 되도는 프로세스다.
어떤 규칙의 한 단계에서 똑같은 규칙을 다시 밟도록 해놓았다.
이렇게 한 프로세스를 되밟는 것(깊이 겹쳐 쓴 식을 계산하는 것 같이) 복잡한 프로세스를 나타내는데 얼마나 도움이 되는걸까>

>예시코드
```sceme
;: (* (+ 2 (* 4 6))
;:    (+ 3 5 7))
```

![binarytreeThatExplainCombination](https://velog.velcdn.com/images/urtimeislimited/post/44289dcf-d3e6-4cef-82ca-aeec10a16cbc/image.png)

- 연산자 : 마디(node)
- 연산할 것들 : 가지(branch)
- 가지가 끝나는 마디 : terminal node

피연산자의 값들은 끝마디부터 가지를 타고 하나씩 더 높은 단계로 올라가며 노드와 엮이는 셈이다.
보통 이렇게 같은 절자를 여러 번 되밟는 기법,
recursion(재귀)는 나무 같은 계층 구조 물체(데이터)를 다루기에 알맞은 기법이라고 한다.

위처럼 값을 위로 올려보내는 규칙은 [tree accumulation](https://en.wikipedia.org/wiki/Tree_accumulation)이라는 일반적 계산방법 중 하나라고 한다.

#### syntax
앞의 규칙에서 첫 단계를 여러번 되밟다 보면,
숫자나 built-in operator같은 기본 식을 계산해야 할 때가 온다. 기본 식을 다루는 규칙은 다음과 같다.
>
- 숫자 식의 값은 여러 숫자가 모여 나타내는 값이다.
- built-in operator의 값은 그 연산자가 뜻하는 연산을 하도록 미리 묶어놓은 기계 명령들이다.
- 그 밖에 다른 이름 값은 환경에서 그 이름으로 정의해둔 물체다.

+와 *같은 기호가 바탕 환경 속에서 그런 연산을 하도록 묶어 둔 기계 명령(값)들로 정의되어 있다.
즉, 식 속에서 쓰는 이름이 무슨 뜻인지 결정짓는 것은 __환경__이다.
프로그램 작동 방식을 이해하는데 context(문맥)을 결정 짓는 환경 개념이 정말 중요한 몫을 한다고 한다.
(define)

보통 계산 규칙으로는 값을 구하지 못할 수 있기 때문에,
(x라는 이름의 뜻이 무엇인지 환경 정보에 밝혀두지 않으면 + x 1 같은 식을 계산해도 의미 없다.)
이름의 값을 정하는 define 처럼
계산 규칙이 따로 밝혀져 있어야 하는 special form(특별한 형태)의 문법이 필요하다.

이렇게 **여러 종류의 식과 식의 종류마다 다른 값을 구하는 규칙이 모여서 프로그래밍 언어의 문법을 이루게 된다.**

나는
문법의 기본 구조 -> 식을 셈하는 규칙 + 몇 안 되는 특별한 형태를 계산하는 규칙의 조합
이라고 이해했다.

---
