![컴퓨터 프로그램의 구조와 해석](https://image.aladin.co.kr/product/7512/20/cover500/8966261701_1.jpg)

## 출처
- [컴퓨터 프로그램의 구조와 해석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=75122015)

---


### 1.1.5 맞바꿈 계산법(substitution model)으로 프로시저를 실행하는 방법
#### 프로시저 실행 과정

프로그래밍한 프로시저를 실행하는 과정은 기본 프로시저의 경우와 거의 같다.
- 모든 부분 식의 값을 구한다. -> 연산자의 값으로 나온 프로시저를 연산할 값, 곧 인자에 맞추어 계산하면 된다.

인자에 맞추어 기본 프로시저를 계산하는 방법은 이미 실행기 속에 정해져있다고 보고, 새로 만들어 쓰는 묶음 프로시저의 맞춤 적용,application은 다음 규칙에 따라 계산할 수 있다.

묶음 프로시저를 인자에 맞춘다는 것은,
프로시저의 몸 속에 있는 모든 formal parameter(인자 이름)을 각각 대응하는 인자 값으로 맞바꾼 다음,
그렇게 얻어낸 식의 값을 구하는 것이다.

#### 1.1.4 프로시저 뜯어보기
```scheme
(f 5)
```
```scheme
(sum-of-squares (+ a 1)(* a 2))
```
인자 이름(a) ↔︎ 인자 값(5) 교환
```scheme
sum-of-squares (+ 5 1)( * 5 2))
```
sum-of-squares 연산자, 피연산자 두 개를 엮은 식이 된다.
```scheme
sum-of-squares (+ 5 1)( * 5 2))
```
세 가지 문제가 풀린다.
- 연산자 값 구하여 프로시저 얻기
- 피연산자(나머지 두 식)의 값 구하기
- 구한 값을 sum-of-squares에 인자로 할당
```scheme
(squares 6)(squares 10)
```
같은 원리를 재귀한다!
```scheme
+ (* 6 6)(*10 10)
```
```scheme
(+ 36 100)
;;; 136
```

>
이런 process(과정)에 따라 __프로시저를 맞추는 방법(procedure application)__ 맞바꿈 계산법substitution model이라고 한다고 한다.
프로시저를 인자에 맞춘다는게 무슨 뜻인지 주시해보자.

#### 맞바꿈 계산법?
- 프로시저를 어떻게 인자에 맞추는지 이해하는데 도움을 주려고 밝혔을 뿐, 실행기가 정말 그렇게 돌아간다는 뜻은 아니라고 한다.
대개 실행기가 인자 이름을 인자 값으로 맞바꿀 때에는 프로시저를 글자 그대로 보고 낱말을 바꿔치는 방법을 쓰지 않는다고 한다.
실제론 local environment(갇힌 환경)에 인자 이름을 넣어놓고 계산하는 방법을 쓴다.
"환경 계산법"이라는 이름으로 이 문제를 더 깊이 살펴볼 수 있다.
- 점점 더 정교한 계산법, 실행기가 어떻게 돌아가는지 차례로 보여주다가 5장에 이르러 완전한 실행기와 번역기를 내놓을 것이다. 맞바꿈 계산법은 그런 계산 모형 중 하나이고, 식의 계산과정에 대하여 제대로 형식을 갖추고 생각을 정리하려는 출발점일 뿐이라고 한다.
- 처음엔 단순하고 덜 만든 모형에서 시작해서 사물이나 현상을 점점 더 깊이 살펴보면서, 처음에 정리한 단순한 모형이 잘 들어맞지 않는다는 것을 알도 조금씩 더 꼼꼼하고 잘 다듬은 모형으로 바꾸어 보자.

#### 인자 먼저 계산법(applicated order)과 정의대로 계산법(normal order)

식의 값을 구하는 방법은 연산자와 피연산자를 먼저 계산하고, 연산자 프로시저를 연산할 인자에 맞추는 방법만 있는 것이 아니다.

값이 필요할 때까지 피연산자들을 계산하지 않고 미루어 두는 방법도 있다.
인자 값을 계산하지 않고 식 자체를 parameter(인자 이름)와 맞바꾸어 가다가
마지막에 primitive operator(기본 연산)으로만 이루어진 식, 즉 더 펼치지 못하는 식을 얻을 때 그 식의 값을 구하는 방법이 있다.

```scheme
;: (f 5)
;: (sum-of-squares (+ 5 1) (* 5 2))
;: (+    (square (+ 5 1))      (square (* 5 2))  )
;: (+    (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))
;: (+         (* 6 6)             (* 10 10))
;: (+           36                   100)
;:                     136
```

값은 같지만 계산 프로세스가 다르다.
특히 식을 줄여나가면서 저마다 두번씩 계산되는 부분을 주시해보면, 모두 뜯어본 후 식을 줄여가는 방식임을 알 수 있다.
이와 같이
>
- normal-order-evaluation : '끝까지 펼친 다음에 줄이는' 계산 방법, 정의한 대로 계산하는 법

-  applicative-order-evaluation : 인자 값부터 먼저 계산하는 방법, 인자 먼저 계산법
	- 같은 식 재귀하는 경우가 없어서 빠르고 가볍게 계산
    - 맞바꿈 계산법이 통하지 않는 프로시저가 있을 때에는 정의대로 계산하는 규칙이 더 복잡하기 때문에 사용

지금은 '정의대로'냐 '인자 먼저' 관계 없이 같은 값이 나오지만 나중에 어떤 계산법이냐에 따라 서로 다른 값이 나오는 바르지 않은 값이 나오는 경우도 볼 수 있다.
